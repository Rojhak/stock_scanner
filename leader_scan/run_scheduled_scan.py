# leader_scan/run_scheduled_scan.py
"""
Script to run leader and specific advanced scans (MA_CROSS) for all universes
and send a combined email alert. Designed for scheduled execution.
"""
import sys
import logging
import datetime as dt
import pandas as pd
import time # Make sure time is imported if you use time.sleep()
import numpy as np # Import numpy for np.nan

# Configure logging FIRST
log_level = logging.INFO # Or logging.DEBUG
logging.basicConfig(level=log_level, format='%(asctime)s - ScheduledScan - %(levelname)s - %(message)s', force=True)
log = logging.getLogger(__name__)

# Import leader_scan components AFTER logging is set up
try:
    # Using absolute imports as intended when running with `python -m leader_scan.run_scheduled_scan`
    from leader_scan.main import run_scan_for_all_universes
    from leader_scan.advanced_screener import run_advanced_scan_for_all
    from leader_scan.alert import dispatch
    from leader_scan.config import CONFIG
except ImportError as e:
    # Fallback for potential direct execution issues (less ideal)
    try:
        log.warning(f"Initial import failed ({e}), trying relative imports...")
        from .main import run_scan_for_all_universes
        from .advanced_screener import run_advanced_scan_for_all
        from .alert import dispatch
        from .config import CONFIG
    except ImportError as e_rel:
        # ADD THIS PRINT for better debug if imports fail:
        print(f"--- FATAL ERROR DURING IMPORT (Relative Fallback): {type(e_rel).__name__}: {e_rel} ---", flush=True)
        log.critical(f"Failed import leader_scan components (standard and relative): {e_rel}. Check PYTHONPATH or if script is run from parent directory.", exc_info=True)
        sys.exit(1)
except Exception as e:
    # ADD THIS PRINT for better debug if imports fail:
    print(f"--- FATAL ERROR DURING IMPORT (General): {type(e).__name__}: {e} ---", flush=True)
    log.critical(f"Unexpected error during imports: {e}", exc_info=True)
    sys.exit(1)

# --- Configuration ---
TOP_N = 5 # Get Top 5 results per universe as requested
BENCHMARK = CONFIG.get("schedule_benchmark", "SPY")
# Use MA_CROSS type for the advanced scan filter
ADVANCED_SETUP_TYPE_FILTER = "MA_CROSS"
# Define display columns (ensure these match columns generated by your chosen scorer)
DISPLAY_COLS_LEADER = ['symbol', 'date', 'setup_type', 'score', 'r_multiple', 'Close', 'stop', 'target']
# Advanced screener might use 'entry' instead of 'Close' if defined differently in scorer
DISPLAY_COLS_ADV = ['symbol', 'date', 'setup_type', 'score', 'r_multiple', 'entry', 'stop', 'target']

def format_results_for_email(results_dict: dict, title: str, display_cols: list) -> str:
    """Formats results from a dictionary {universe: DataFrame} into a string."""
    body = f"--- {title} (Top {TOP_N}) ---\n\n"
    found_any = False
    if not results_dict or not isinstance(results_dict, dict):
        body += "No results found or results format incorrect.\n"
        return body

    sorted_universes = sorted(results_dict.keys())
    for universe in sorted_universes:
        df = results_dict.get(universe)
        # Ensure df is a non-empty pandas DataFrame
        if isinstance(df, pd.DataFrame) and not df.empty:
            found_any = True
            body += f"=== {universe.upper()} ===\n"
            temp_df = df.copy()
            # Select only columns that actually exist in the DataFrame
            final_cols_existing = [col for col in display_cols if col in temp_df.columns]

            if not final_cols_existing:
                body += "No display columns found in results DataFrame.\n\n"
                continue # Skip if no columns to display

            # Format date if present
            if 'date' in temp_df.columns:
                try:
                    # Ensure date is formatted correctly, handle potential errors
                    temp_df['date'] = pd.to_datetime(temp_df['date'], errors='coerce').dt.strftime('%Y-%m-%d')
                except Exception:
                    log.warning(f"Could not format date column for {universe} in {title}", exc_info=False)
                    pass # Keep original if formatting fails

            # Format numbers and create string representation
            try:
                body += temp_df[final_cols_existing].to_string(index=False, float_format="%.2f") + "\n\n"
            except Exception as e:
                 log.error(f"Error formatting DataFrame to string for {universe} in {title}: {e}")
                 body += f"Error displaying results for {universe}.\n\n"

        # else:
            # Optional: Report empty universes if desired
            # log.info(f"No results DataFrame found for universe '{universe}' in '{title}'.")
            # body += f"=== No results found for {universe.upper()} ===\n\n"

    if not found_any:
        body += f"No setups found matching criteria in any universe for {title}.\n"
    return body

def main():
    """Main execution function for scheduled scan."""
    # ADDED DEBUG PRINT
    print("--- DEBUG: Entered main() function ---", flush=True)
    log.info("Starting scheduled scan run...")
    # Check for essential email config from environment variables/secrets
    if not all([CONFIG.get("smtp_host"), CONFIG.get("smtp_user"), CONFIG.get("smtp_password"), CONFIG.get("from_email"), CONFIG.get("to_emails")]):
        log.error("Email configuration incomplete via ENV VARS (LS_...). Cannot send alert.")
        sys.exit(1)

    log.info(f"Running standard leader scan (Top {TOP_N}, Benchmark {BENCHMARK})...")
    leader_results = run_scan_for_all_universes(top_per_universe=TOP_N, benchmark=BENCHMARK, return_results=True)

    log.info(f"Running advanced scan (Top {TOP_N}, Type {ADVANCED_SETUP_TYPE_FILTER}, Benchmark {BENCHMARK})...")
    advanced_results = run_advanced_scan_for_all(top_per_universe=TOP_N, setup_type_filter=ADVANCED_SETUP_TYPE_FILTER, benchmark=BENCHMARK, return_results=True)

    # Add debug logs for intermediate results
    log.debug(f"Leader Results Type: {type(leader_results)}")
    if isinstance(leader_results, dict):
        for k, v in leader_results.items(): log.debug(f"  Leader Key: {k}, Type: {type(v)}, Empty: {v.empty if isinstance(v, pd.DataFrame) else 'N/A'}")
    log.debug(f"Advanced Results Type: {type(advanced_results)}")
    if isinstance(advanced_results, dict):
        for k, v in advanced_results.items(): log.debug(f"  Advanced Key: {k}, Type: {type(v)}, Empty: {v.empty if isinstance(v, pd.DataFrame) else 'N/A'}")

    # --- Start of Corrected Block for Duplicate Check ---
    are_results_identical = False # Assume not identical initially
    # Check if both results are dictionaries and have the same keys (universes)
    if isinstance(leader_results, dict) and isinstance(advanced_results, dict):
        if leader_results.keys() == advanced_results.keys():
            identical = True # Assume identical until proven otherwise
            log.debug(f"Comparing results for keys: {list(leader_results.keys())}") # Debug keys
            for key in leader_results:
                df_leader = leader_results.get(key)
                df_advanced = advanced_results.get(key)

                # Check if both values are pandas DataFrames before comparing
                if isinstance(df_leader, pd.DataFrame) and isinstance(df_advanced, pd.DataFrame):
                    try:
                        # Use pandas .equals() for robust comparison (checks labels and values)
                        if not df_leader.equals(df_advanced):
                            identical = False
                            log.debug(f"Results for '{key}' differ using .equals().")
                            break # Stop checking if one differs
                    except Exception as e:
                        log.warning(f"Error comparing DataFrames for key '{key}' using .equals(): {e}")
                        identical = False # Assume not identical if comparison fails
                        break
                # Handle cases where one or both might be None or not a DataFrame for a given key
                elif df_leader is not df_advanced: # If types differ or one is None, they aren't identical
                    identical = False
                    log.debug(f"Result types for '{key}' differ or one is None.")
                    break
            # If the loop completed without finding differences, they are identical
            are_results_identical = identical
            log.debug(f"Finished key comparison. Are results identical? {are_results_identical}")
        else:
             log.debug("Result dictionaries have different keys (universes). Not identical.")
             are_results_identical = False # Keys differ, so not identical
    elif leader_results is not advanced_results: # Handle cases where one might be None or not a dict at all
         are_results_identical = False
         log.debug(f"Result types are different (dict vs {type(advanced_results)} or vice versa) or one is None. Not identical.")


    if are_results_identical:
        log.warning("Leader and Advanced scan results appear identical based on content. Skipping advanced results in email.")
        advanced_results = None # Set advanced_results to None ONLY if confirmed identical
    # --- End of Corrected Block ---


    log.info("Formatting email body...")
    today_str = dt.date.today().strftime('%Y-%m-%d')
    subject = f"Stock Scan Results - {today_str}" # Updated Subject

    email_body = f"Scan Report for {today_str}\n"
    email_body += "="*40 + "\n\n"

    # Format Leader Scan Results
    email_body += format_results_for_email(leader_results, "Standard Leader Scan", DISPLAY_COLS_LEADER)
    email_body += "="*40 + "\n\n"

    # Format Advanced Scan Results (if not skipped or empty)
    # This logic now also handles the case where advanced_results was set to None by the check above
    if advanced_results:
        email_body += format_results_for_email(advanced_results, f"Advanced Scan ({ADVANCED_SETUP_TYPE_FILTER})", DISPLAY_COLS_ADV)
        email_body += "="*40 + "\n"
    else:
        # Explicitly state if advanced results are skipped or were empty
        if are_results_identical:
             email_body += f"--- Advanced Scan ({ADVANCED_SETUP_TYPE_FILTER}) (Top {TOP_N}) ---\n\n"
             email_body += "Results identical to Standard Leader Scan, not repeated.\n"
             email_body += "="*40 + "\n"
        else:
             # Handle case where advanced_results was initially empty (not due to duplication)
             email_body += f"--- Advanced Scan ({ADVANCED_SETUP_TYPE_FILTER}) (Top {TOP_N}) ---\n\n"
             email_body += f"No setups found matching criteria in any universe for Advanced Scan ({ADVANCED_SETUP_TYPE_FILTER}).\n"
             email_body += "="*40 + "\n"


    # Send Email using dispatch function from alert.py
    log.info(f"Attempting to send combined email alert to: {CONFIG.get('to_emails')}")
    try:
        dispatch(subject, email_body)
        log.info("Combined email alert dispatched successfully.")
    except Exception as e:
        log.error(f"Failed to send combined email alert: {e}", exc_info=True)
        sys.exit(1) # Exit if dispatch fails

    log.info("Scheduled scan run finished successfully.")


# --- ADD THIS BLOCK AT THE VERY END OF THE FILE ---
# (Your previous version might have had the print statement inside here already)
# ADDED DEBUG PRINTS
print("--- DEBUG: Reached end of script top-level ---", flush=True)
print(f"--- DEBUG: __name__ is set to: {__name__} ---", flush=True)

if __name__ == "__main__":
    print("--- DEBUG: Entered __main__ block, calling main() ---", flush=True)
    main()
# --- END OF ADDED/MODIFIED BLOCK ---